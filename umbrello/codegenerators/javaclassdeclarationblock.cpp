
/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/

/*  This code generated by:
 *      Author : thomas
 *      Date   : Wed Jul 16 2003
 */

#include "javaclassdeclarationblock.h"
#include "javacodecomment.h"

// Constructors/Destructors
//  

JavaClassDeclarationBlock::JavaClassDeclarationBlock ( JavaClassifierCodeDocument * parentDoc, QString startText, QString endText, QString comment)
    : OwnedHierarchicalCodeBlock((UMLObject*) parentDoc->getParentClassifier(), (CodeDocument*)parentDoc, startText, endText, comment)
{
	init(parentDoc, comment);
};

JavaClassDeclarationBlock::~JavaClassDeclarationBlock ( ) { };

//  
// Methods
//  


// Accessor methods
//  

// Other methods
//  

/**
 * update the start and end text for this hierarchicalcodeblock.
 */
void JavaClassDeclarationBlock::updateContent ( ) 
{

	JavaClassifierCodeDocument *parentDoc = (JavaClassifierCodeDocument*)getParentDocument();
	UMLClassifier *c = parentDoc->getParentClassifier();
        CodeGenerator *g = parentDoc->getParentGenerator();
	QString endLine = parentDoc->getNewLineEndingChars();
        bool isInterface = parentDoc->parentIsInterface(); // a little shortcut
        QString JavaClassName = parentDoc->getJavaClassName(c->getName());

	// COMMENT
        if(isInterface)
        	getComment()->setText("Interface "+JavaClassName+endLine+c->getDoc());
        else
        	getComment()->setText("Class "+JavaClassName+endLine+c->getDoc());

        if(g->forceDoc() || !c->getDoc().isEmpty())
		getComment()->setWriteOutText(true);
	else
		getComment()->setWriteOutText(false);


	// Now set START/ENDING Text
        QString startText = "";
        if (c->getAbstract())
                startText.append("abstract ");

        if (c->getScope() != Uml::Public) {
                // We should probably emit a warning in here .. java doesnt like to allow
                // private/protected classes. The best we can do (I believe)
                // is to let these declarations default to "package visibility"
                // which is a level between traditional "private" and "protected"
                // scopes. To get this visibility level we just print nothing..
        } else
                startText.append("public ");

        if(parentDoc->parentIsInterface())
                startText.append("interface ");
        else
                startText.append("class ");

        startText.append(JavaClassName);

        // write inheritances out
        UMLClassifier *concept;
        UMLClassifierList superclasses =
                        c->findSuperClassConcepts(parentDoc->getParentGenerator()->getDocument());

        if(superclasses.count()>0)
                startText.append(" extends ");

        int i = 0;
        for (concept= superclasses.first(); concept; concept = superclasses.next())
        {
                startText.append(parentDoc->cleanName(concept->getName()));
                if(i>0)
                        startText.append(", ");
                i++;
        }

// FIX
// Q: Where is 'implements' ??

        // Set the header and end text for the hier.codeblock
        setText(startText+" {");

	// setEndText("}"); // not needed 

}

void JavaClassDeclarationBlock::init (JavaClassifierCodeDocument *parentDoc, QString comment) 
{

	setComment(new JavaCodeComment(parentDoc));
	getComment()->setText(comment);

	setEndText("}");

	updateContent(); 

// FIX : for implements..
	// connect to modified signal of parent object. NOTE IF we 
	// implement the "implements" part, we will need to connect
	// to the modified signal of each of the parent classes to
	// our class, which is problematic. WHy? because the associations
	// can be changing all of the time and we dont necessarily want
	// to have to keep track of all of that.

// note: next line not needed CONNECT already done by parent class
        // connect(c,SIGNAL(modified()),this,SLOT(syncToParent())); 

}


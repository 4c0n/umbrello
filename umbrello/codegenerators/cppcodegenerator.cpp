
/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/

/*  This code generated by:
 *      Author : thomas
 *      Date   : Thu Jun 19 2003
 */

#include <kdebug.h>
#include <kconfig.h>

#include <qregexp.h>

#include "cppcodegenerator.h"
#include "cppcodedocumentation.h"
#include "cppcodegenerationpolicy.h"
#include "cppsourcecodedocument.h"
#include "cppheadercodedocument.h"

#include "codeviewerdialog.h"

const bool CPPCodeGenerator::DEFAULT_BUILD_MAKEFILE = false;

// Constructors/Destructors
//

CPPCodeGenerator::CPPCodeGenerator ( UMLDoc * parentDoc , const char * name)
    : CodeGenerator( parentDoc, name ) {

	//m_parentDoc = parentDoc; // this should be done by the call to the parent constructor?
	initAttributes();
}

CPPCodeGenerator::~CPPCodeGenerator ( ) {
	// destroy all separately owned codedocuments (e.g. header docs)
	QPtrList<CodeDocument> * list = &m_headercodedocumentVector;
	for (CodeDocument *doc = list->first(); doc; doc=list->next())
		delete doc;
}

//
// Methods
//

// Accessor methods
//

/**
 * returns "Cpp"
 */
QString CPPCodeGenerator::getLanguage() {
	return "Cpp";
}

/**
 * checks whether type is "CPPCodeGenerator"
 *
 * @param type
 */
bool CPPCodeGenerator::isType (QString & type)
{
   if(type == "CPPCodeGenerator")
	return true;
   return false;
}

/**
 * Set the value of m_createMakefile
 * @param new_var the new value of m_createMakefile
 */
void CPPCodeGenerator::setCreateProjectMakefile ( bool buildIt) {
	m_createMakefile = buildIt;
	CodeDocument * antDoc = findCodeDocumentByID(CPPMakefileCodeDocument::DOCUMENT_ID_VALUE);
	if (antDoc)
		antDoc->setWriteOutCode(buildIt);
}

/**
 * Get the value of m_createMakefile
 * @return the value of m_createMakefile
 */
bool CPPCodeGenerator::getCreateProjectMakefile ( ) {
	return m_createMakefile;
}

bool CPPCodeGenerator::addHeaderCodeDocument ( CPPHeaderCodeDocument * doc )
{

	QString tag = doc->getID();

	// assign a tag if one doesnt already exist
	if(tag.isEmpty())
	{
		tag = "cppheader"+ID2STR(doc->getParentClassifier()->getID());
		doc->setID(tag);
	}

	if(m_codeDocumentDictionary.find(tag))
		return false; // return false, we already have some object with this tag in the list
	else
		m_codeDocumentDictionary.insert(tag, doc);

	m_headercodedocumentVector.append(doc);
	return true;
}

/**
 * Remove a header CodeDocument object from m_headercodedocumentVector List
 */
bool CPPCodeGenerator::removeHeaderCodeDocument ( CPPHeaderCodeDocument * remove_object ) {
	QString tag = remove_object->getID();
	if(!(tag.isEmpty()))
		m_codeDocumentDictionary.remove(tag);
	else
		return false;

	m_headercodedocumentVector.remove(remove_object);
	return true;
}

// In the C++ version, we need to make both source and header files as well
// as the makefile available.
CodeViewerDialog * CPPCodeGenerator::getCodeViewerDialog ( QWidget* parent, CodeDocument *doc,
							   Settings::CodeViewerState state)
{

	ClassifierCodeDocument * cdoc = dynamic_cast<ClassifierCodeDocument*>(doc);
	if(!cdoc)
		// bah..not a classcode document?? then just use vanilla version
		return CodeGenerator::getCodeViewerDialog(parent,doc,state);
	else {
		// build with passed (source) code document
		CodeViewerDialog *dialog;

		// use classifier to find appropriate header document
		UMLClassifier * c = cdoc->getParentClassifier();
		CPPHeaderCodeDocument * hdoc = findHeaderCodeDocumentByClassifier(c);
		if(hdoc)
		{
			// if we have a header document..build with that
			dialog = new CodeViewerDialog(parent, hdoc, state);
			dialog->addCodeDocument(doc);
		} else
			// shouldnt happen, but lets try to gracefully deliver something.
			dialog = new CodeViewerDialog(parent, doc, state);

		// add in makefile if available and desired
		if(getCreateProjectMakefile())
			dialog->addCodeDocument(findCodeDocumentByID(CPPMakefileCodeDocument::DOCUMENT_ID_VALUE));

		return dialog;
	}
}

QString CPPCodeGenerator::getCPPClassName (const QString &name) {
	return cleanName(name);
}

CPPCodeGenerationPolicy::CPPCommentStyle CPPCodeGenerator::getCommentStyle ( )
{
	return ((CPPCodeGenerationPolicy*)getPolicy())->getCommentStyle();
}

bool CPPCodeGenerator::getAutoGenerateConstructors ( )
{
	return ((CPPCodeGenerationPolicy*)getPolicy())->getAutoGenerateConstructors();
}

bool CPPCodeGenerator::getAutoGenerateAccessors ( )
{
	return ((CPPCodeGenerationPolicy*)getPolicy())->getAutoGenerateAccessors ();
}

// Other methods
//

// CHange the following dataTypes to the ones the user really
// wants in their code. Not yet complete.
QString CPPCodeGenerator::fixTypeName(QString string)
{
// FIX!!
	string.replace(QRegExp("^[Ll]ist$"),"QPtrList");
	string.replace(QRegExp("^string$"),"QString");
	return cleanName(string);
}

// special method needed so that we write out the header code documents
void CPPCodeGenerator::saveToXMI ( QDomDocument & doc, QDomElement & root ) {
	QString langType = getLanguage();
	QDomElement docElement = doc.createElement( "codegenerator" );
	docElement.setAttribute("language",langType);

	QPtrList<CodeDocument> * docList = getCodeDocumentList();
	for (CodeDocument * codeDoc = docList->first(); codeDoc; codeDoc= docList->next())
		codeDoc->saveToXMI(doc, docElement);

	for (CodeDocument * hcodeDoc = m_headercodedocumentVector.first(); hcodeDoc; hcodeDoc=m_headercodedocumentVector.next())
		hcodeDoc->saveToXMI(doc, docElement);

	root.appendChild( docElement );
}

/**
 * Force a synchronize of this code generator, and its present contents, to that of the parent UMLDocument.
 * Need to override parent method because we have header documents to consider too.
 */
void CPPCodeGenerator::syncCodeToDocument ( ) {

	QPtrList<CodeDocument> * docList = getCodeDocumentList();

	for (CodeDocument * doc = docList->first(); doc; doc=docList->next())
		doc->synchronize();

	for (CodeDocument * hcodeDoc = m_headercodedocumentVector.first(); hcodeDoc; hcodeDoc=m_headercodedocumentVector.next())
		hcodeDoc->synchronize();

}

/**
 * Write out all code documents to file as appropriate.
 */
void CPPCodeGenerator::writeCodeToFile ( )
{
	// write all source documents (incl. Makefile)
	writeListedCodeDocsToFile(getCodeDocumentList());

	// write all header documents
	writeListedCodeDocsToFile(&m_headercodedocumentVector);

}

// overridden because we need to be able to generate code for
// both the header and source documents
void CPPCodeGenerator::writeCodeToFile ( UMLClassifierList & concepts) {
	QPtrList<CodeDocument> docs;
	docs.setAutoDelete(false);

	for (UMLClassifier *concept= concepts.first(); concept; concept= concepts.next())
	{
		CodeDocument * doc = findCodeDocumentByClassifier(concept);
		if(doc)
			docs.append(doc);
		CodeDocument * hdoc = findHeaderCodeDocumentByClassifier(concept);
		if(hdoc)
			docs.append(hdoc);
	}

	writeListedCodeDocsToFile(&docs);
}


/**
 * Find a cppheadercodedocument by the given classifier.
 * @return      CPPHeaderCodeDocument
* @param       classifier
*/
CPPHeaderCodeDocument * CPPCodeGenerator::findHeaderCodeDocumentByClassifier (UMLClassifier * classifier )
{
	CodeDocument * doc = findCodeDocumentByID("cppheader"+ID2STR(classifier->getID()));
	return dynamic_cast<CPPHeaderCodeDocument*>(doc);
}

/**
 * @return	ClassifierCodeDocument
 * @param	classifier
 * @param	this This package generator object.
 */
// source document version.
CodeDocument * CPPCodeGenerator::newClassifierCodeDocument (UMLClassifier * classifier)
{
	return new CPPSourceCodeDocument(classifier, this);
}

CodeComment * CPPCodeGenerator::newCodeComment ( CodeDocument * doc) {
	return new CPPCodeDocumentation(doc);
}

CPPHeaderCodeDocument * CPPCodeGenerator::newHeaderClassifierCodeDocument (UMLClassifier * classifier)
{
	return new CPPHeaderCodeDocument(classifier, this);
}

/**
 * @return	CPPMakefileCodeDocument
 * @param	this
 */
CPPMakefileCodeDocument * CPPCodeGenerator::newMakefileCodeDocument ( ) {
	return new CPPMakefileCodeDocument (this);
}


/**
 * Overloaded so that we may have both source and header documents for each
 * classifier.
 */
void CPPCodeGenerator::initFromParentDocument( ) {

	// Walk through the document converting classifiers into
	// classifier code documents as needed (e.g only if doesnt exist)
	UMLClassifierList concepts = getDocument()->getClassesAndInterfaces();
	for (UMLClassifier *c = concepts.first(); c; c = concepts.next())
	{

		// Doesnt exist? Then build one.
		CodeDocument * codeDoc = findCodeDocumentByClassifier(c);
		if (!codeDoc)
		{
			codeDoc = newClassifierCodeDocument(c);
			addCodeDocument(codeDoc); // this will also add a unique tag to the code document
		}

		CPPHeaderCodeDocument * hcodeDoc = findHeaderCodeDocumentByClassifier(c);
		if (!hcodeDoc)
		{
			hcodeDoc = new CPPHeaderCodeDocument(c,this);
			addHeaderCodeDocument(hcodeDoc); // this will also add a unique tag to the code document
		}
	}

}

// need to worry about adding both source, and header documents for each
// classifier
void CPPCodeGenerator::checkAddUMLObject (UMLObject * obj) {
	if (!obj)
		return;

	UMLClassifier * c = dynamic_cast<UMLClassifier*>(obj);
	if(c) {
		CodeDocument * cDoc = newClassifierCodeDocument(c);
		CPPHeaderCodeDocument * hcodeDoc = new CPPHeaderCodeDocument(c, this);
		addCodeDocument(cDoc);
		addHeaderCodeDocument(hcodeDoc); // this will also add a unique tag to the code document
	}
}

// need to worry about removing both source, and header documents for each
// classifier
void CPPCodeGenerator::checkRemoveUMLObject (UMLObject * obj)
{

	if (!obj)
		return;

	UMLClassifier * c = dynamic_cast<UMLClassifier*>(obj);
	if(c) {

		// source
		ClassifierCodeDocument * cDoc = (ClassifierCodeDocument*) findCodeDocumentByClassifier(c);
		if (cDoc)
			removeCodeDocument(cDoc);

		// header
		CPPHeaderCodeDocument * hcodeDoc = findHeaderCodeDocumentByClassifier(c);
		if (hcodeDoc)
			removeHeaderCodeDocument(hcodeDoc);
	}

}

void CPPCodeGenerator::initAttributes ( )
{

	setPolicy ( new CPPCodeGenerationPolicy(this, getPolicy()) );

       // load Classifier documents from parent document
	initFromParentDocument();

	// add in an Make build document
	CPPMakefileCodeDocument * buildDoc = newMakefileCodeDocument( );
	addCodeDocument(buildDoc);

	// set our 'writeout' policy for that code document
	setCreateProjectMakefile(DEFAULT_BUILD_MAKEFILE);

}

// should be 'static'
QString CPPCodeGenerator::scopeToCPPDecl(Uml::Scope scope)
{
	QString scopeString;
	switch(scope)
	{
		case Uml::Public:
			scopeString = "public";
			break;
		case Uml::Protected:
			scopeString = "protected";
			break;
		case Uml::Private:
		default:
			scopeString = "private";
			break;
	}
	return scopeString;
}

void CPPCodeGenerator::createDefaultDatatypes() {
	m_document->createDatatype("int");
	m_document->createDatatype("char");
	m_document->createDatatype("bool");
	m_document->createDatatype("float");
	m_document->createDatatype("double");
	m_document->createDatatype("long");
	m_document->createDatatype("short");
	m_document->createDatatype("string");
}

const QStringList CPPCodeGenerator::reservedKeywords() const {

  static QStringList keywords;

  if (keywords.isEmpty()) {
    keywords.append( "and" );
    keywords.append( "and_eq" );
    keywords.append( "__asm__" );
    keywords.append( "asm" );
    keywords.append( "__attribute__" );
    keywords.append( "auto" );
    keywords.append( "bitand" );
    keywords.append( "bitor" );
    keywords.append( "bool" );
    keywords.append( "break" );
    keywords.append( "BUFSIZ" );
    keywords.append( "case" );
    keywords.append( "catch" );
    keywords.append( "char" );
    keywords.append( "CHAR_BIT" );
    keywords.append( "CHAR_MAX" );
    keywords.append( "CHAR_MIN" );
    keywords.append( "class" );
    keywords.append( "CLOCKS_PER_SEC" );
    keywords.append( "clock_t" );
    keywords.append( "compl" );
    keywords.append( "__complex__" );
    keywords.append( "complex" );
    keywords.append( "const" );
    keywords.append( "const_cast" );
    keywords.append( "continue" );
    keywords.append( "__DATE__" );
    keywords.append( "DBL_DIG" );
    keywords.append( "DBL_EPSILON" );
    keywords.append( "DBL_MANT_DIG" );
    keywords.append( "DBL_MAX" );
    keywords.append( "DBL_MAX_10_EXP" );
    keywords.append( "DBL_MAX_EXP" );
    keywords.append( "DBL_MIN" );
    keywords.append( "DBL_MIN_10_EXP" );
    keywords.append( "DBL_MIN_EXP" );
    keywords.append( "default" );
    keywords.append( "delete" );
    keywords.append( "DIR" );
    keywords.append( "div_t" );
    keywords.append( "do" );
    keywords.append( "double" );
    keywords.append( "dynamic_cast" );
    keywords.append( "E2BIG" );
    keywords.append( "EACCES" );
    keywords.append( "EAGAIN" );
    keywords.append( "EBADF" );
    keywords.append( "EBADMSG" );
    keywords.append( "EBUSY" );
    keywords.append( "ECANCELED" );
    keywords.append( "ECHILD" );
    keywords.append( "EDEADLK" );
    keywords.append( "EDOM" );
    keywords.append( "EEXIST" );
    keywords.append( "EFAULT" );
    keywords.append( "EFBIG" );
    keywords.append( "EILSEQ" );
    keywords.append( "EINPROGRESS" );
    keywords.append( "EINTR" );
    keywords.append( "EINVAL" );
    keywords.append( "EIO" );
    keywords.append( "EISDIR" );
    keywords.append( "else" );
    keywords.append( "EMFILE" );
    keywords.append( "EMLINK" );
    keywords.append( "EMSGSIZE" );
    keywords.append( "ENAMETOOLONG" );
    keywords.append( "ENFILE" );
    keywords.append( "ENODEV" );
    keywords.append( "ENOENT" );
    keywords.append( "ENOEXEC" );
    keywords.append( "ENOLCK" );
    keywords.append( "ENOMEM" );
    keywords.append( "ENOSPC" );
    keywords.append( "ENOSYS" );
    keywords.append( "ENOTDIR" );
    keywords.append( "ENOTEMPTY" );
    keywords.append( "ENOTSUP" );
    keywords.append( "ENOTTY" );
    keywords.append( "enum" );
    keywords.append( "ENXIO" );
    keywords.append( "EOF" );
    keywords.append( "EPERM" );
    keywords.append( "EPIPE" );
    keywords.append( "ERANGE" );
    keywords.append( "EROFS" );
    keywords.append( "ESPIPE" );
    keywords.append( "ESRCH" );
    keywords.append( "ETIMEDOUT" );
    keywords.append( "EXDEV" );
    keywords.append( "EXIT_FAILURE" );
    keywords.append( "EXIT_SUCCESS" );
    keywords.append( "explicit" );
    keywords.append( "export" );
    keywords.append( "extern" );
    keywords.append( "false" );
    keywords.append( "__FILE__" );
    keywords.append( "FILE" );
    keywords.append( "FILENAME_MAX" );
    keywords.append( "float" );
    keywords.append( "FLT_DIG" );
    keywords.append( "FLT_EPSILON" );
    keywords.append( "FLT_MANT_DIG" );
    keywords.append( "FLT_MAX" );
    keywords.append( "FLT_MAX_10_EXP" );
    keywords.append( "FLT_MAX_EXP" );
    keywords.append( "FLT_MIN" );
    keywords.append( "FLT_MIN_10_EXP" );
    keywords.append( "FLT_MIN_EXP" );
    keywords.append( "FLT_RADIX" );
    keywords.append( "FLT_ROUNDS" );
    keywords.append( "FOPEN_MAX" );
    keywords.append( "for" );
    keywords.append( "fpos_t" );
    keywords.append( "friend" );
    keywords.append( "__FUNCTION__" );
    keywords.append( "__GNUC__" );
    keywords.append( "goto" );
    keywords.append( "HUGE_VAL" );
    keywords.append( "if" );
    keywords.append( "__imag__" );
    keywords.append( "inline" );
    keywords.append( "int" );
    keywords.append( "INT16_MAX" );
    keywords.append( "INT16_MIN" );
    keywords.append( "int16_t" );
    keywords.append( "INT32_MAX" );
    keywords.append( "INT32_MIN" );
    keywords.append( "int32_t" );
    keywords.append( "INT64_MAX" );
    keywords.append( "INT64_MIN" );
    keywords.append( "int64_t" );
    keywords.append( "INT8_MAX" );
    keywords.append( "INT8_MIN" );
    keywords.append( "int8_t" );
    keywords.append( "INT_FAST16_MAX" );
    keywords.append( "INT_FAST16_MIN" );
    keywords.append( "int_fast16_t" );
    keywords.append( "INT_FAST32_MAX" );
    keywords.append( "INT_FAST32_MIN" );
    keywords.append( "int_fast32_t" );
    keywords.append( "INT_FAST64_MAX" );
    keywords.append( "INT_FAST64_MIN" );
    keywords.append( "int_fast64_t" );
    keywords.append( "INT_FAST8_MAX" );
    keywords.append( "INT_FAST8_MIN" );
    keywords.append( "int_fast8_t" );
    keywords.append( "INT_LEAST16_MAX" );
    keywords.append( "INT_LEAST16_MIN" );
    keywords.append( "int_least16_t" );
    keywords.append( "INT_LEAST32_MAX" );
    keywords.append( "INT_LEAST32_MIN" );
    keywords.append( "int_least32_t" );
    keywords.append( "INT_LEAST64_MAX" );
    keywords.append( "INT_LEAST64_MIN" );
    keywords.append( "int_least64_t" );
    keywords.append( "INT_LEAST8_MAX" );
    keywords.append( "INT_LEAST8_MIN" );
    keywords.append( "int_least8_t" );
    keywords.append( "INT_MAX" );
    keywords.append( "INTMAX_MAX" );
    keywords.append( "INTMAX_MIN" );
    keywords.append( "intmax_t" );
    keywords.append( "INT_MIN" );
    keywords.append( "INTPTR_MAX" );
    keywords.append( "INTPTR_MIN" );
    keywords.append( "intptr_t" );
    keywords.append( "_IOFBF" );
    keywords.append( "_IOLBF" );
    keywords.append( "_IONBF" );
    keywords.append( "jmp_buf" );
    keywords.append( "__label__" );
    keywords.append( "LC_ALL" );
    keywords.append( "LC_COLLATE" );
    keywords.append( "LC_CTYPE" );
    keywords.append( "LC_MONETARY" );
    keywords.append( "LC_NUMERIC" );
    keywords.append( "LC_TIME" );
    keywords.append( "LDBL_DIG" );
    keywords.append( "LDBL_EPSILON" );
    keywords.append( "LDBL_MANT_DIG" );
    keywords.append( "LDBL_MAX" );
    keywords.append( "LDBL_MAX_10_EXP" );
    keywords.append( "LDBL_MAX_EXP" );
    keywords.append( "LDBL_MIN" );
    keywords.append( "LDBL_MIN_10_EXP" );
    keywords.append( "LDBL_MIN_EXP" );
    keywords.append( "ldiv_t" );
    keywords.append( "__LINE__" );
    keywords.append( "LLONG_MAX" );
    keywords.append( "long" );
    keywords.append( "LONG_MAX" );
    keywords.append( "LONG_MIN" );
    keywords.append( "L_tmpnam" );
    keywords.append( "M_1_PI" );
    keywords.append( "M_2_PI" );
    keywords.append( "M_2_SQRTPI" );
    keywords.append( "MB_CUR_MAX" );
    keywords.append( "MB_LEN_MAX" );
    keywords.append( "mbstate_t" );
    keywords.append( "M_E" );
    keywords.append( "M_LN10" );
    keywords.append( "M_LN2" );
    keywords.append( "M_LOG10E" );
    keywords.append( "M_LOG2E" );
    keywords.append( "M_PI" );
    keywords.append( "M_PI_2" );
    keywords.append( "M_PI_4" );
    keywords.append( "M_SQRT1_2" );
    keywords.append( "M_SQRT2" );
    keywords.append( "mutable" );
    keywords.append( "namespace" );
    keywords.append( "new" );
    keywords.append( "not" );
    keywords.append( "not_eq" );
    keywords.append( "NPOS" );
    keywords.append( "NULL" );
    keywords.append( "operator" );
    keywords.append( "or" );
    keywords.append( "or_eq" );
    keywords.append( "__PRETTY_FUNCTION__" );
    keywords.append( "private" );
    keywords.append( "protected" );
    keywords.append( "PTRDIFF_MAX" );
    keywords.append( "PTRDIFF_MIN" );
    keywords.append( "ptrdiff_t" );
    keywords.append( "public" );
    keywords.append( "RAND_MAX" );
    keywords.append( "__real__" );
    keywords.append( "register" );
    keywords.append( "reinterpret_cast" );
    keywords.append( "restrict" );
    keywords.append( "return" );
    keywords.append( "SCHAR_MAX" );
    keywords.append( "SCHAR_MIN" );
    keywords.append( "SEEK_CUR" );
    keywords.append( "SEEK_END" );
    keywords.append( "SEEK_SET" );
    keywords.append( "short" );
    keywords.append( "SHRT_MAX" );
    keywords.append( "SHRT_MIN" );
    keywords.append( "SIGABRT" );
    keywords.append( "SIGALRM" );
    keywords.append( "SIG_ATOMIC_MAX" );
    keywords.append( "SIG_ATOMIC_MIN" );
    keywords.append( "sig_atomic_t" );
    keywords.append( "SIGCHLD" );
    keywords.append( "SIGCONT" );
    keywords.append( "SIG_DFL" );
    keywords.append( "SIG_ERR" );
    keywords.append( "SIGFPE" );
    keywords.append( "SIGHUP" );
    keywords.append( "SIG_IGN" );
    keywords.append( "SIGILL" );
    keywords.append( "SIGINT" );
    keywords.append( "SIGKILL" );
    keywords.append( "signed" );
    keywords.append( "SIGPIPE" );
    keywords.append( "SIGQUIT" );
    keywords.append( "SIGSEGV" );
    keywords.append( "SIGSTOP" );
    keywords.append( "SIGTERM" );
    keywords.append( "SIGTRAP" );
    keywords.append( "SIGTSTP" );
    keywords.append( "SIGTTIN" );
    keywords.append( "SIGTTOU" );
    keywords.append( "SIGUSR1" );
    keywords.append( "SIGUSR2" );
    keywords.append( "SINT_MAX" );
    keywords.append( "SINT_MIN" );
    keywords.append( "SIZE_MAX" );
    keywords.append( "sizeof" );
    keywords.append( "size_t" );
    keywords.append( "SLONG_MAX" );
    keywords.append( "SLONG_MIN" );
    keywords.append( "SSHRT_MAX" );
    keywords.append( "SSHRT_MIN" );
    keywords.append( "ssize_t" );
    keywords.append( "static" );
    keywords.append( "static_cast" );
    keywords.append( "__STDC__" );
    keywords.append( "__STDC_VERSION__" );
    keywords.append( "stderr" );
    keywords.append( "stdin" );
    keywords.append( "stdout" );
    keywords.append( "struct" );
    keywords.append( "switch" );
    keywords.append( "template" );
    keywords.append( "this" );
    keywords.append( "throw" );
    keywords.append( "__TIME__" );
    keywords.append( "time_t" );
    keywords.append( "TMP_MAX" );
    keywords.append( "true" );
    keywords.append( "try" );
    keywords.append( "typedef" );
    keywords.append( "typeid" );
    keywords.append( "typename" );
    keywords.append( "typeof" );
    keywords.append( "UCHAR_MAX" );
    keywords.append( "UINT16_MAX" );
    keywords.append( "uint16_t" );
    keywords.append( "UINT32_MAX" );
    keywords.append( "uint32_t" );
    keywords.append( "UINT64_MAX" );
    keywords.append( "uint64_t" );
    keywords.append( "UINT8_MAX" );
    keywords.append( "uint8_t" );
    keywords.append( "UINT_FAST16_MAX" );
    keywords.append( "uint_fast16_t" );
    keywords.append( "UINT_FAST32_MAX" );
    keywords.append( "uint_fast32_t" );
    keywords.append( "UINT_FAST64_MAX" );
    keywords.append( "uint_fast64_t" );
    keywords.append( "UINT_FAST8_MAX" );
    keywords.append( "uint_fast8_t" );
    keywords.append( "UINT_LEAST16_MAX" );
    keywords.append( "uint_least16_t" );
    keywords.append( "UINT_LEAST32_MAX" );
    keywords.append( "uint_least32_t" );
    keywords.append( "UINT_LEAST64_MAX" );
    keywords.append( "uint_least64_t" );
    keywords.append( "UINT_LEAST8_MAX" );
    keywords.append( "uint_least8_t" );
    keywords.append( "UINT_MAX" );
    keywords.append( "UINTMAX_MAX" );
    keywords.append( "uintmax_t" );
    keywords.append( "UINTPTR_MAX" );
    keywords.append( "uintptr_t" );
    keywords.append( "ULLONG_MAX" );
    keywords.append( "ULONG_MAX" );
    keywords.append( "union" );
    keywords.append( "unsigned" );
    keywords.append( "USHRT_MAX" );
    keywords.append( "using" );
    keywords.append( "va_list" );
    keywords.append( "virtual" );
    keywords.append( "void" );
    keywords.append( "__volatile__" );
    keywords.append( "volatile" );
    keywords.append( "WCHAR_MAX" );
    keywords.append( "WCHAR_MIN" );
    keywords.append( "wchar_t" );
    keywords.append( "wctrans_t" );
    keywords.append( "wctype_t" );
    keywords.append( "WEOF" );
    keywords.append( "while" );
    keywords.append( "WINT_MAX" );
    keywords.append( "WINT_MIN" );
    keywords.append( "wint_t" );
    keywords.append( "xor" );
    keywords.append( "xor_eq" );
  }

  return keywords;
}

#include "cppcodegenerator.moc"
